% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/misc.R
\name{normalize_cov}
\alias{normalize_cov}
\title{Normalize and weight data sets}
\usage{
normalize_cov(x, normalize = "decorrelate", norm_cov = NULL,
  weights = NULL)
}
\arguments{
\item{x}{a numeric matrix or data frame.}

\item{normalize}{the type of normalization to be done. This must
be one of "none", "decorrelate" or "sd_normalize". "decorrelate"
normalizes with \code{norm_cov} and "sd_normalize" normalizes with
the diagonal of \code{norm_cov}.}

\item{norm_cov}{a numeric vector or matrix of the same dimensions
as columns in \code{x} to be used for normalization. If a vector
a diagonal matrix is constructed. If \code{NULL} the sample
covariance is used, \code{norm_cov = var(x)}.}

\item{weights}{a numeric vector or matrix of the same dimensions
  as columns in \code{x} with weights for each covariate. If a vector
  a diagonal matrix is constructed. \code{NULL}
  gives no weighting (i.e., a vector or ones).}
}
\value{
\code{normalize_cov} returns a matrix with normalized and
  weighted columns.
}
\description{
This function normalizes and weights data sets. A data set (data frame or matrix)
of \code{n} rows and \code{m} columns is supplied and a matrix of the same
dimensions is returned with normalized and weighted columns.
}
\details{
If \code{norm_cov}
is the (estimated) covariance matrix and \code{normalize == "decorrelate"} then
the Euclidean distances between rows in the returned matrix is equivalent to
Mahalanobis distances between the corresponding rows in the original matrix.
With the same \code{norm_cov} but with \code{normalize == "sd_normalize"},
the Euclidean distances in the returned matrix is equivalent to normalized
Euclidean distances in the original matrix.
}
\examples{
data <- matrix(rnorm(600), ncol = 3)
data[, 2] <- data[, 1] + data[, 2]
data[, 3] <- (data[, 1] + 1) * data[, 3]

round(var(data), digits = 3)

data <- normalize_cov(data)

round(var(data), digits = 3)
}

