% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/get_blocking.R
\name{get_blocking}
\alias{get_blocking}
\title{Construct threshold blocking}
\usage{
get_blocking(data, block_size, directed = TRUE,
  MIS_method = "heuristicSearch", unassinged_method = "seed_search",
  treetype = "kdtree")
}
\arguments{
\item{data}{a numeric matrix or data frame describing the covariates
of the units in the experiment.}

\item{block_size}{the desired minimum block size.}

\item{directed}{whether the directed version of the algorithm should
be used.}

\item{MIS_method}{the method to find a maximal independent set with.
Must be one of "lexical", "1stPowOrder", "2ndPowOrder", "heuristicSearch"
or "MaxIS".}

\item{unassinged_method}{how to assign vertices that are unassigned in the
last step of the algorithm.}

\item{treetype}{the method to find nearest neighbors with. Must be one
  of "brute", "kdtree" or "bdtree". "kdtree" is recommended in most cases
  but for small samples or high dimensional covariates "brute" might perform
  better. For highly clustered data "bdtree" might perform best.}
}
\value{
\code{get_blocking} returns a data frame where one variable is the
  units' labels (\code{1:n}) and one variable is their block membership.
  Details about the used algorithm is added as attributes to the data frame.
}
\description{
This function produces an approximately optimal solution to the
threshold blocking problem where the objective is to minimize
the maximum Euclidean distances between any two units
within the same block.
}
\section{Large data sets}{


\code{get_blocking} works well with large data sets (several millions of
data points) but some parameter values can lead to extensive run time.
Generally \code{algorithm == "directed"} is slightly faster than
\code{algorithm == "undirected"}. For data sets with less than
100,000 data points \code{MIS_method == "heuristicSearch"} usually
works well. For bigger data sets (less than ten million points)
\code{MIS_method == "2ndPowOrder"} is to prefer. Very large data sets
should consider "lexical" or "1stPowOrder". \code{MIS_method == "MaxIS"}
is usually only feasible with data sets with data points in the lower hundreds.

The function is fastest with \code{algorithm == "directed"} and
\code{MIS_method == "lexical"}. The time complexity is then
\eqn{O(kn log n)}. Using "undirected", "1stPowOrder" or
"2ndPowOrder" add steps taking \eqn{O(kn)} time with
varying constants. Calling with "heuristicSearch" adds a step
with \eqn{O(kn^1.5)} over "2ndPowOrder". "MaxIS" is NP-hard.
}
\examples{
# Generate data sets
x1 <- rnorm(200)
data <- data.frame(x1 = x1, x2 = x1 + rnorm(200), x3 = x1 * runif(200))
large_data <- data.frame(x1 = rnorm(1e+6), x2 = runif(1e+6))

# Euclidean distances
blocking1 <- get_blocking(data, 4)

# Mahalanobis distances
data_maha <- normalize_cov(data)
blocking2 <- get_blocking(data_maha, 4)

# Change `MIS_method' for large data sets
blocking3 <- get_blocking(large_data, 4, MIS_method = "2ndPowOrder")
}

